<!doctype html>
<html>

<head>
    <meta charset="utf-8" />
    <title>P2P Demo — Send (Multi-file)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
        body {
            font: 16px/1.4 system-ui, sans-serif;
            max-width: 820px;
            margin: 40px auto;
        }

        .row {
            margin: 12px 0;
        }

        progress {
            width: 100%;
            height: 16px;
        }

        code {
            background: #f1f3f5;
            padding: 2px 6px;
            border-radius: 4px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th,
        td {
            border-bottom: 1px solid #eee;
            padding: 6px 8px;
            text-align: left;
        }
    </style>
</head>

<body>
    <h1>Send files (P2P)</h1>

    <div class="row">
        <input id="files" type="file" multiple />
    </div>

    <div class="row">
        <button id="createLink" disabled>Create link</button>
    </div>

    <div class="row" id="linkBox" style="display:none;">
        Share this link with the receiver:<br>
        <input id="shareLink" style="width:100%;" readonly />
    </div>

    <div class="row">
        <div>Status: <span id="status">Idle</span></div>
        <div>Overall progress:</div>
        <progress id="progTotal" value="0" max="100"></progress>
        <div><small><span id="sentBytes">0</span>/<span id="totalBytes">0</span> bytes</small></div>
    </div>

    <div class="row" id="filesTableWrap" style="display:none;">
        <table>
            <thead>
                <tr>
                    <th>File</th>
                    <th>Size</th>
                    <th>Progress</th>
                </tr>
            </thead>
            <tbody id="filesTbody"></tbody>
        </table>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const input = document.getElementById('files');
        const createBtn = document.getElementById('createLink');
        const linkBox = document.getElementById('linkBox');
        const shareLink = document.getElementById('shareLink');
        const statusEl = document.getElementById('status');
        const progTotal = document.getElementById('progTotal');
        const sentBytesEl = document.getElementById('sentBytes');
        const totalBytesEl = document.getElementById('totalBytes');
        const filesTableWrap = document.getElementById('filesTableWrap');
        const filesTbody = document.getElementById('filesTbody');

        let files = [], linkId, socket, pc, dc;
        let perFileSent = [];
        let totalSize = 0, totalSent = 0;

        input.addEventListener('change', () => {
            files = Array.from(input.files || []);
            createBtn.disabled = files.length === 0;
            if (!files.length) return;
            // build table
            filesTableWrap.style.display = 'block';
            filesTbody.innerHTML = '';
            perFileSent = files.map(() => 0);
            totalSize = files.reduce((s, f) => s + f.size, 0);
            totalSent = 0;
            totalBytesEl.textContent = totalSize.toString();
            sentBytesEl.textContent = '0';

            for (const f of files) {
                const tr = document.createElement('tr');
                tr.innerHTML = `
          <td>${escapeHtml(f.name)}</td>
          <td>${f.size}</td>
          <td>
            <progress max="100" value="0" data-name="${escapeHtml(f.name)}"></progress>
          </td>`;
                filesTbody.appendChild(tr);
            }
        });

        createBtn.addEventListener('click', async () => {
            if (!files.length) return;
            linkId = genId();
            const url = `${location.origin}/receive?id=${linkId}`;
            shareLink.value = url;
            linkBox.style.display = 'block';
            setStatus('Waiting for receiver…');

            // signaling
            socket = io();
            socket.emit('join', { linkId, role: 'sender' });
            socket.on('peer-joined', ({ role }) => {
                if (role === 'receiver') startConnection();
            });
            socket.on('signal', async (payload) => {
                if (payload.type === 'answer') {
                    await pc.setRemoteDescription(payload.sdp);
                } else if (payload.type === 'ice') {
                    try { await pc.addIceCandidate(payload.candidate); } catch { }
                }
            });
        });

        async function startConnection() {
            pc = new RTCPeerConnection({
                iceServers: [{ urls: ['stun:stun.l.google.com:19302'] }]
            });
            pc.onicecandidate = (e) => {
                if (e.candidate) {
                    socket.emit('signal', { linkId, payload: { type: 'ice', candidate: e.candidate } });
                }
            };
            dc = pc.createDataChannel('file', { ordered: true });
            dc.binaryType = 'arraybuffer';
            dc.onopen = () => sendFiles();
            dc.onclose = () => setStatus('Data channel closed');

            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);
            socket.emit('signal', { linkId, payload: { type: 'offer', sdp: offer } });
        }

        async function sendFiles() {
            setStatus('Connected. Sending…');

            // 1) send MANIFEST with list of files
            const manifest = {
                type: 'manifest',
                version: 1,
                files: files.map(f => ({ name: f.name, size: f.size, type: f.type }))
            };
            dc.send(JSON.stringify(manifest));

            // flow control
            const chunkSize = 64 * 1024;
            const low = 512 * 1024;
            dc.bufferedAmountLowThreshold = low;

            // 2) send each file with start/end markers
            for (let i = 0; i < files.length; i++) {
                const f = files[i];
                dc.send(JSON.stringify({ type: 'start', index: i, name: f.name, size: f.size, fileType: f.type || 'application/octet-stream' }));

                let offset = 0;
                while (offset < f.size) {
                    const slice = await f.slice(offset, offset + chunkSize).arrayBuffer();
                    dc.send(slice);
                    offset += slice.byteLength;

                    // progress
                    perFileSent[i] = offset;
                    totalSent = perFileSent.reduce((s, x) => s + x, 0);
                    sentBytesEl.textContent = totalSent.toString();
                    const overallP = totalSize ? Math.floor((totalSent / totalSize) * 100) : 0;
                    progTotal.value = overallP;

                    const pf = document.querySelector(`progress[data-name="${cssSel(f.name)}"]`);
                    if (pf) pf.value = f.size ? Math.floor((offset / f.size) * 100) : 0;

                    if (dc.bufferedAmount > low) await waitForBufferLow();
                }

                dc.send(JSON.stringify({ type: 'end', index: i }));
            }

            // 3) all done
            dc.send(JSON.stringify({ type: 'all_done' }));
            setStatus('Done.');
        }

        function waitForBufferLow() {
            return new Promise((resolve) => {
                const onLow = () => { dc.removeEventListener('bufferedamountlow', onLow); resolve(); };
                dc.addEventListener('bufferedamountlow', onLow);
                setTimeout(() => { try { dc.removeEventListener('bufferedamountlow', onLow); } catch { }; resolve(); }, 150);
            });
        }

        function setStatus(s) { statusEl.textContent = s; }
        function genId() {
            const arr = new Uint8Array(9);
            crypto.getRandomValues(arr);
            return Array.from(arr, b => b.toString(16).padStart(2, '0')).join('');
        }
        function escapeHtml(s) { return s.replace(/[&<>"'`=\/]/g, c => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;', '/': '&#x2F;', '`': '&#x60;', '=': '&#x3D;' }[c])); }
        function cssSel(s) { return s.replace(/"/g, '\\"'); }
    </script>
</body>

</html>